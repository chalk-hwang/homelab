authentication = [
  {
    backend = postgresql
    database = emqx
    mechanism = password_based
    password = "file:///run/secrets/emqx_auth_db_password"
    password_hash_algorithm {name = bcrypt}
    pool_size = 4
    query = "SELECT password_hash, is_superuser FROM mqtt_users where username = ${username} LIMIT 1"
    server = "timescaledb:5432"
    ssl {enable = false, verify = verify_peer}
    username = emqx
  }
]
authorization {
  cache {
    enable = true
    excludes = []
    max_size = 32
    ttl = "1m"
  }
  deny_action = ignore
  no_match = allow
  sources = [
    {
      enable = true
      path = "data/authz/acl.conf"
      type = file
    }
  ]
}
listeners {
  ssl {
    default {
      acceptors = 16
      access_rules = [
        "allow all"
      ]
      bind = "0.0.0.0:8883"
      enable = true
      enable_authn = true
      max_conn_rate = infinity
      max_connections = infinity
      mountpoint = ""
      proxy_protocol = false
      proxy_protocol_timeout = "3s"
      ssl_options {
        cacertfile = "${EMQX_ETC_DIR}/certs/cacert.pem"
        certfile = "${EMQX_ETC_DIR}/certs/cert.pem"
        ciphers = []
        client_renegotiation = true
        depth = 10
        enable_crl_check = false
        fail_if_no_peer_cert = false
        gc_after_handshake = false
        handshake_timeout = "15s"
        hibernate_after = "5s"
        honor_cipher_order = true
        keyfile = "${EMQX_ETC_DIR}/certs/key.pem"
        log_level = notice
        ocsp {
          enable_ocsp_stapling = false
          refresh_http_timeout = "15s"
          refresh_interval = "5m"
        }
        reuse_sessions = true
        secure_renegotiate = true
        verify = verify_none
        versions = [
          "tlsv1.3",
          "tlsv1.2"
        ]
      }
      tcp_options {
        active_n = 100
        backlog = 1024
        buffer = "4KB"
        high_watermark = "1MB"
        keepalive = none
        nodelay = true
        reuseaddr = true
        send_timeout = "15s"
        send_timeout_close = true
      }
      zone = default
    }
  }
  tcp {
    default {
      acceptors = 16
      access_rules = [
        "allow all"
      ]
      bind = "0.0.0.0:1883"
      enable = true
      enable_authn = true
      max_conn_rate = infinity
      max_connections = infinity
      mountpoint = ""
      proxy_protocol = false
      proxy_protocol_timeout = "3s"
      tcp_options {
        active_n = 100
        backlog = 1024
        buffer = "4KB"
        high_watermark = "1MB"
        keepalive = none
        nodelay = true
        reuseaddr = true
        send_timeout = "15s"
        send_timeout_close = true
      }
      zone = default
    }
  }
  ws {
    default {
      acceptors = 16
      access_rules = [
        "allow all"
      ]
      bind = "0.0.0.0:8083"
      enable = true
      enable_authn = true
      max_conn_rate = infinity
      max_connections = infinity
      mountpoint = ""
      proxy_protocol = false
      proxy_protocol_timeout = "3s"
      tcp_options {
        active_n = 100
        backlog = 1024
        buffer = "4KB"
        high_watermark = "1MB"
        keepalive = none
        nodelay = true
        reuseaddr = true
        send_timeout = "15s"
        send_timeout_close = true
      }
      websocket {
        allow_origin_absence = true
        check_origin_enable = false
        check_origins = "http://localhost:18083, http://127.0.0.1:18083"
        compress = false
        deflate_opts {
          client_context_takeover = takeover
          client_max_window_bits = 15
          mem_level = 8
          server_context_takeover = takeover
          server_max_window_bits = 15
          strategy = default
        }
        fail_if_no_subprotocol = true
        idle_timeout = "7200s"
        max_frame_size = infinity
        mqtt_path = "/mqtt"
        mqtt_piggyback = multiple
        proxy_address_header = "x-forwarded-for"
        proxy_port_header = "x-forwarded-port"
        supported_subprotocols = "mqtt, mqtt-v3, mqtt-v3.1.1, mqtt-v5"
        validate_utf8 = true
      }
      zone = default
    }
  }
  wss {
    default {
      acceptors = 16
      access_rules = [
        "allow all"
      ]
      bind = "0.0.0.0:8084"
      enable = true
      enable_authn = true
      max_conn_rate = infinity
      max_connections = infinity
      mountpoint = ""
      proxy_protocol = true
      proxy_protocol_timeout = "3s"
      ssl_options {
        cacertfile = "${EMQX_ETC_DIR}/certs/cacert.pem"
        certfile = "${EMQX_ETC_DIR}/certs/cert.pem"
        ciphers = []
        client_renegotiation = true
        depth = 10
        fail_if_no_peer_cert = false
        handshake_timeout = "15s"
        hibernate_after = "5s"
        honor_cipher_order = true
        keyfile = "${EMQX_ETC_DIR}/certs/key.pem"
        log_level = notice
        reuse_sessions = true
        secure_renegotiate = true
        verify = verify_none
        versions = [
          "tlsv1.3",
          "tlsv1.2"
        ]
      }
      tcp_options {
        active_n = 100
        backlog = 1024
        buffer = "4KB"
        high_watermark = "1MB"
        keepalive = none
        nodelay = true
        reuseaddr = true
        send_timeout = "15s"
        send_timeout_close = true
      }
      websocket {
        allow_origin_absence = true
        check_origin_enable = false
        check_origins = "http://localhost:18083, http://127.0.0.1:18083"
        compress = false
        deflate_opts {
          client_context_takeover = takeover
          client_max_window_bits = 15
          mem_level = 8
          server_context_takeover = takeover
          server_max_window_bits = 15
          strategy = default
        }
        fail_if_no_subprotocol = true
        idle_timeout = "7200s"
        max_frame_size = infinity
        mqtt_path = "/mqtt"
        mqtt_piggyback = multiple
        proxy_address_header = "x-forwarded-for"
        proxy_port_header = "x-forwarded-port"
        supported_subprotocols = "mqtt, mqtt-v3, mqtt-v3.1.1, mqtt-v5"
        validate_utf8 = true
      }
      zone = default
    }
  }
}
log {
  console {
    enable = true
    formatter = text
    level = warning
    time_offset = system
    timestamp_format = auto
  }
  file {
    default {
      enable = true
      formatter = text
      level = warning
      path = "/opt/emqx/log/emqx.log"
      rotation_count = 10
      rotation_size = "50MB"
      time_offset = system
      timestamp_format = auto
    }
  }
  throttling {
    time_window = "1m"
  }
}
mqtt {
  await_rel_timeout = "300s"
  client_attrs_init = []
  exclusive_subscription = false
  idle_timeout = "15s"
  ignore_loop_deliver = true
  keepalive_check_interval = "30s"
  keepalive_multiplier = 1.5
  max_awaiting_rel = 100
  max_clientid_len = 65535
  max_inflight = 32
  max_mqueue_len = 1000
  max_packet_size = "1MB"
  max_qos_allowed = 2
  max_subscriptions = infinity
  max_topic_alias = 65535
  max_topic_levels = 128
  message_expiry_interval = infinity
  mqueue_default_priority = lowest
  mqueue_priorities = disabled
  mqueue_store_qos0 = true
  peer_cert_as_clientid = disabled
  peer_cert_as_username = disabled
  response_information = ""
  retain_available = true
  retry_interval = "30s"
  server_keepalive = disabled
  session_expiry_interval = "2h"
  shared_subscription = true
  shared_subscription_strategy = round_robin
  strict_mode = false
  upgrade_qos = true
  use_username_as_clientid = false
  wildcard_subscription = true
}
retainer {
  backend {
    enable = true
    index_specs = [[1, 2, 3], [1, 3], [2, 3], [3]]
    max_retained_messages = 0
    storage_type = ram
    type = built_in_database
  }
  delivery_rate = "1000/s"
  enable = true
  flow_control {
    batch_deliver_limiter {
      client {
        rate = "1000/s"
      }
      rate = infinity
    }
    batch_deliver_number = 1000
    batch_read_number = 1000
  }
  max_payload_size = "2MB"
  msg_clear_interval = "0s"
  msg_expiry_interval = "0s"
  stop_publish_clear_msg = false
}
sys_topics {
  sys_event_messages {
    client_connected = true
    client_disconnected = true
    client_subscribed = true
    client_unsubscribed = true
  }
  sys_heartbeat_interval = "30s"
  sys_msg_interval = "1m"
}
topic_metrics = [
  {topic = "/homeassistant/"}
]